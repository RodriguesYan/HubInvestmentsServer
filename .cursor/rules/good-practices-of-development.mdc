---
description: 
globs: 
alwaysApply: true
---
# Good Practices of Development

## Table of Contents
1. [Avoiding Nested If Statements](#avoiding-nested-if-statements)
2. [Early Returns Pattern](#early-returns-pattern)
3. [Method Extraction](#method-extraction)
4. [Meaningful Comments](#meaningful-comments)
5. [Clean Code Principles](#clean-code-principles)

## Avoiding Nested If Statements

### ❌ Problem: Nested Ifs Reduce Code Readability

Nested if statements create complex, hard-to-read code that is difficult to maintain and test.

**Bad Example:**
```go
func ValidateOrder(order *Order) error {
    if order != nil {
        if order.Quantity > 0 {
            if order.Price != nil {
                if *order.Price > 0 {
                    if order.Symbol != "" {
                        // actual validation logic buried deep
                        return nil
                    } else {
                        return errors.New("symbol required")
                    }
                } else {
                    return errors.New("price must be positive")
                }
            } else {
                return errors.New("price required")
            }
        } else {
            return errors.New("quantity must be positive")
        }
    } else {
        return errors.New("order cannot be nil")
    }
}
```

### ✅ Solution: Use Early Returns and Guard Clauses

Transform nested conditions into early return statements for better readability.

**Good Example:**
```go
func ValidateOrder(order *Order) error {
    if order == nil {
        return errors.New("order cannot be nil")
    }
    
    if order.Quantity <= 0 {
        return errors.New("quantity must be positive")
    }
    
    if order.Price == nil {
        return errors.New("price required")
    }
    
    if *order.Price <= 0 {
        return errors.New("price must be positive")
    }
    
    if order.Symbol == "" {
        return errors.New("symbol required")
    }
    
    // actual validation logic at the main level
    return nil
}
```

## Early Returns Pattern

### Benefits of Early Returns

1. **Reduced Cognitive Load**: Less mental effort to understand the code
2. **Clearer Intent**: Each validation is explicit and isolated
3. **Easier Testing**: Each condition can be tested independently
4. **Better Maintainability**: Adding/removing validations is straightforward

### ❌ Problem: Unnecessary else-if with Early Returns

When using early returns, `else if` and `else` clauses become redundant and add unnecessary complexity.

**Bad Example:**
```go
func GetOrderStatus(orderID string) string {
    if orderID == "" {
        return "invalid"
    } else if order.Status == "pending" {
        return "waiting"
    } else if order.Status == "executed" {
        return "completed"
    } else {
        return "unknown"
    }
}
```

### ✅ Solution: Eliminate else-if with Early Returns

When each condition has a return statement, subsequent conditions don't need `else if`.

**Good Example:**
```go
func GetOrderStatus(orderID string) string {
    if orderID == "" {
        return "invalid"
    }
    
    if order.Status == "pending" {
        return "waiting"
    }
    
    if order.Status == "executed" {
        return "completed"
    }
    
    return "unknown"
}
```

### Guidelines for Early Returns

#### 1. Validate Input Parameters First
```go
func ProcessOrder(order *Order, client Client) error {
    // Validate inputs first with early returns
    if order == nil {
        return ErrOrderNil
    }
    
    if client == nil {
        return ErrClientNil
    }
    
    // Main business logic continues...
}
```

#### 2. Handle Error Conditions Early
```go
func GetUserBalance(userID string) (float64, error) {
    if userID == "" {
        return 0, ErrInvalidUserID
    }
    
    user, err := userRepo.FindByID(userID)
    if err != nil {
        return 0, fmt.Errorf("failed to find user: %w", err)
    }
    
    if !user.IsActive {
        return 0, ErrUserInactive
    }
    
    // Happy path logic continues...
    return user.Balance, nil
}
```

#### 3. Use Guard Clauses for State Validation
```go
func ExecuteOrder(order *Order) error {
    if order.Status != StatusPending {
        return ErrInvalidOrderStatus
    }
    
    if order.IsExpired() {
        return ErrOrderExpired
    }
    
    // Execution logic...
}
```

## Method Extraction

### ❌ Problem: Long Methods with Multiple Responsibilities

```go
func ValidateOrderWithContext(order *Order, client MarketDataClient) error {
    // Symbol validation (10 lines)
    isValid, err := client.ValidateSymbol(order.Symbol)
    if err != nil {
        return fmt.Errorf("symbol validation failed: %w", err)
    }
    if !isValid {
        return ErrInvalidSymbol
    }
    
    // Price validation (15 lines)
    currentPrice, err := client.GetCurrentPrice(order.Symbol)
    if err != nil {
        return fmt.Errorf("failed to get price: %w", err)
    }
    tolerance := 0.1
    if abs(order.Price - currentPrice) / currentPrice > tolerance {
        return ErrPriceOutOfRange
    }
    
    // Trading hours validation (12 lines)
    isOpen, err := client.IsMarketOpen(order.Symbol)
    if err != nil {
        return fmt.Errorf("failed to check market hours: %w", err)
    }
    if !isOpen {
        return ErrMarketClosed
    }
    
    return nil
}
```

### ✅ Solution: Extract Methods for Each Responsibility

```go
func ValidateOrderWithContext(order *Order, client MarketDataClient) error {
    if err := s.validateSymbol(order.Symbol, client); err != nil {
        return err
    }
    
    if err := s.validatePrice(order, client); err != nil {
        return err
    }
    
    if err := s.validateTradingHours(order.Symbol, client); err != nil {
        return err
    }
    
    return nil
}

func (s *Service) validateSymbol(symbol string, client MarketDataClient) error {
    isValid, err := client.ValidateSymbol(symbol)
    if err != nil {
        return fmt.Errorf("symbol validation failed: %w", err)
    }
    
    if !isValid {
        return ErrInvalidSymbol
    }
    
    return nil
}

func (s *Service) validatePrice(order *Order, client MarketDataClient) error {
    currentPrice, err := client.GetCurrentPrice(order.Symbol)
    if err != nil {
        return fmt.Errorf("failed to get price: %w", err)
    }
    
    tolerance := 0.1
    if abs(order.Price - currentPrice) / currentPrice > tolerance {
        return ErrPriceOutOfRange
    }
    
    return nil
}

func (s *Service) validateTradingHours(symbol string, client MarketDataClient) error {
    isOpen, err := client.IsMarketOpen(symbol)
    if err != nil {
        return fmt.Errorf("failed to check market hours: %w", err)
    }
    
    if !isOpen {
        return ErrMarketClosed
    }
    
    return nil
}
```

## Meaningful Comments

### ❌ Problem: Useless Comments That Add No Value

Comments should explain **why** something is done, not **what** is being done. Avoid obvious comments that just restate the code.

**Bad Examples:**
```go
// Set user ID to the provided userID
order.userID = userID

// Check if order is nil
if order == nil {
    return errors.New("order cannot be nil")
}

// Loop through all orders
for _, order := range orders {
    // Process each order
    processOrder(order)
}

// Create new order repository
orderRepo := NewOrderRepository()

// Update order status to processing
order.Status = OrderStatusProcessing
```

### ✅ Solution: Write Comments That Add Value

Only add comments when they provide meaningful context, explain complex business logic, or clarify non-obvious decisions.

**Good Examples:**
```go
// Apply 10% price tolerance to prevent execution during extreme market volatility
tolerance := 0.10
if abs(orderPrice-marketPrice)/marketPrice > tolerance {
    return ErrPriceOutOfRange
}

// Grace period allows cancellation of processing orders within 30 seconds
// This accounts for network delays and gives users a chance to cancel
gracePeriod := 30 * time.Second
if time.Since(order.CreatedAt()) < gracePeriod {
    return nil
}

// Use exponential backoff for retry intervals: 5min → 15min → 1hr → 6hr
// This prevents overwhelming the system during outages while ensuring eventual processing
retryIntervals := []time.Duration{5*time.Minute, 15*time.Minute, 1*time.Hour, 6*time.Hour}

// Market orders execute immediately at current price, but we still validate
// against stale prices to prevent execution with outdated market data
if order.Type == MarketOrder && time.Since(marketData.Timestamp) > 5*time.Second {
    return ErrStaleMarketData
}
```

### When to Write Comments

#### ✅ **DO** Comment These Scenarios:

1. **Complex Business Logic**
```go
// Calculate position-weighted average price including fees and slippage
// Formula: VWAP = Σ(Price × Volume) / Σ(Volume) + EstimatedFees
avgPrice := calculateVWAP(trades, estimatedFees)
```

2. **Non-Obvious Algorithms or Formulas**
```go
// Black-Scholes option pricing model implementation
// Uses risk-free rate, volatility, and time to expiration
optionPrice := blackScholesCall(spot, strike, riskFreeRate, volatility, timeToExpiry)
```

3. **Regulatory or Compliance Requirements**
```go
// SEC Rule 15c3-3 requires segregation of customer funds
// Orders above $250K must be pre-approved by compliance
if orderValue > 250000 {
    return s.requestComplianceApproval(order)
}
```

4. **Workarounds or Temporary Solutions**
```go
// TODO: Remove this workaround once market data provider fixes their API
// Currently their timestamps are in EST instead of UTC
marketTime = marketTime.Add(5 * time.Hour)
```

5. **Performance Optimizations**
```go
// Cache frequently accessed symbols to reduce database queries
// Cache TTL is 5 minutes to balance performance with data freshness
if cachedData, exists := s.symbolCache.Get(symbol); exists {
    return cachedData
}
```

6. **Cross-System Integration Details**
```go
// External broker API expects prices in cents, not dollars
// Convert $123.45 to 12345 cents before sending
priceInCents := int(price * 100)
```

#### ❌ **DON'T** Comment These Scenarios:

1. **Obvious Code Operations**
```go
// BAD: Comment just restates the code
user.Name = "John"  // Set user name to John
```

2. **Standard Language Constructs**
```go
// BAD: Everyone knows what a for loop does
for i := 0; i < len(orders); i++ {  // Loop through orders
```

3. **Self-Explanatory Method Names**
```go
// BAD: Method name already explains what it does
result := order.Validate()  // Validate the order
```

4. **Simple Assignments or Declarations**
```go
// BAD: Obvious variable assignment
orderID := uuid.New().String()  // Generate new order ID
```

### Comment Quality Guidelines

#### 1. **Explain the Why, Not the What**
```go
// BAD: Explains what the code does
if order.Quantity > maxQuantity {
    return ErrQuantityTooLarge
}

// GOOD: Explains why this limit exists
// Prevent market manipulation by limiting single order size to 1% of daily volume
if order.Quantity > maxQuantity {
    return ErrQuantityTooLarge
}
```

#### 2. **Keep Comments Up-to-Date**
```go
// BAD: Outdated comment that no longer matches the code
// Retry 3 times with 1 second delay
for i := 0; i < 5; i++ {  // Code was changed but comment wasn't updated
    time.Sleep(2 * time.Second)
}

// GOOD: Comment matches the actual implementation
// Retry 5 times with 2 second delay to handle temporary network issues
for i := 0; i < 5; i++ {
    time.Sleep(2 * time.Second)
}
```

#### 3. **Use Comments to Explain Complex Interactions**
```go
// Order processing involves multiple systems working in sequence:
// 1. Validate order against market data (real-time price check)
// 2. Check user positions and available balance
// 3. Submit to external broker via API
// 4. Update internal state based on broker response
// 5. Send confirmation to user via notification service
func (s *OrderService) ProcessOrder(order *Order) error {
```

#### 4. **Document Edge Cases and Assumptions**
```go
// Handle the edge case where market closes during order processing
// If this happens, we queue the order for next market open
if !s.isMarketOpen() {
    return s.queueForNextSession(order)
}

// Assumption: All prices are in USD and include 2 decimal places
// External systems may send prices in different formats
normalizedPrice := s.normalizePrice(rawPrice)
```

### Code Documentation vs Comments

#### Use Godoc for Public APIs
```go
// SubmitOrder validates and submits a trading order for processing.
// It performs real-time market data validation, risk checks, and
// returns an order ID for tracking. The order is processed asynchronously.
//
// Parameters:
//   - ctx: Request context for timeout and cancellation
//   - cmd: Order submission command with all required fields
//
// Returns:
//   - OrderID for tracking the order status
//   - Error if validation fails or system is unavailable
//
// Example:
//   result, err := usecase.SubmitOrder(ctx, &SubmitOrderCommand{
//       UserID: "user123",
//       Symbol: "AAPL",
//       Quantity: 100,
//   })
func (uc *SubmitOrderUseCase) SubmitOrder(ctx context.Context, cmd *SubmitOrderCommand) (*SubmitOrderResult, error) {
```

#### Use Inline Comments for Implementation Details
```go
func (uc *SubmitOrderUseCase) validatePrice(order *Order, marketPrice float64) error {
    // Market orders don't need price validation
    if order.Type == MarketOrder {
        return nil
    }
    
    // For limit orders, ensure price is within 10% of current market price
    // This prevents accidental orders due to stale UI data or fat-finger errors
    tolerance := 0.10
    deviation := abs(order.Price - marketPrice) / marketPrice
    
    if deviation > tolerance {
        return fmt.Errorf("order price deviates %.1f%% from market price", deviation*100)
    }
    
    return nil
}
```

## Clean Code Principles

### 1. Single Responsibility Principle
- Each method should have one reason to change
- Extract methods when a function handles multiple concerns

### 2. Meaningful Names
- Use descriptive method names that explain what they do
- `validateSymbolExistence()` is better than `checkSymbol()`

### 3. Small Methods
- Keep methods small and focused (ideally < 20 lines)
- If a method is getting long, extract sub-methods

### 4. Consistent Error Handling
```go
// Consistent pattern for error handling
func (s *Service) validateStep(input Input) error {
    result, err := s.performValidation(input)
    if err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }
    
    if !result.IsValid {
        return ErrValidationFailed
    }
    
    return nil
}
```

### 5. Use Builder Pattern for Complex Validation Results
```go
type ValidationResult struct {
    IsValid  bool
    Errors   []string
    Warnings []string
}

func (r *ValidationResult) AddError(msg string) {
    r.IsValid = false
    r.Errors = append(r.Errors, msg)
}

func (r *ValidationResult) AddWarning(msg string) {
    r.Warnings = append(r.Warnings, msg)
}
```

## Refactoring Checklist

When you encounter nested ifs, ask yourself:

1. **Can I use early returns?** - Convert nested conditions to guard clauses
2. **Can I extract methods?** - Break down complex logic into smaller, focused methods
3. **Can I invert conditions?** - Sometimes inverting the condition logic makes it clearer
4. **Can I use a switch statement?** - For multiple conditional branches
5. **Can I use polymorphism?** - For type-based conditional logic

## Implementation Example: Order Validation Service

The `order_validation_service.go` demonstrates these principles:

- **Early Returns**: Used in `validateSymbolExistence()` and `validateAssetDetails()`
- **Method Extraction**: Complex validation logic split into focused methods
- **Single Responsibility**: Each validation method handles one specific concern
- **Guard Clauses**: Input validation happens first with immediate returns

This approach results in:
- **Better Readability**: Each method is easy to understand
- **Easier Testing**: Each validation can be tested in isolation
- **Better Maintainability**: Adding new validations doesn't affect existing code
- **Reduced Bugs**: Simpler control flow reduces logical errors

## Key Takeaways

1. **Avoid nesting beyond 2 levels** - Extract methods or use early returns
2. **Fail fast** - Validate inputs and error conditions first
3. **One thing per method** - Each method should have a single, clear purpose
4. **Name things clearly** - Method names should explain what they do
5. **Consistent patterns** - Use the same approach throughout your codebase
6. **Eliminate else-if with early returns** - When each condition returns, don't use else-if
7. **Comment meaningfully** - Explain why, not what; focus on business logic and complex scenarios
8. **Avoid obvious comments** - Don't comment standard operations, assignments, or self-explanatory code 